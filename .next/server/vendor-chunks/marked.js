"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(rsc)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ Hooks),\n/* harmony export */   Lexer: () => (/* binding */ Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Renderer: () => (/* binding */ Renderer),\n/* harmony export */   Slugger: () => (/* binding */ Slugger),\n/* harmony export */   TextRenderer: () => (/* binding */ TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v5.1.2 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ function getDefaults() {\n    return {\n        async: false,\n        baseUrl: null,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: \"\",\n        highlight: null,\n        hooks: null,\n        langPrefix: \"language-\",\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n    };\n}\nlet defaults = getDefaults();\nfunction changeDefaults(newDefaults) {\n    defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n/**\n * @param {string} html\n */ function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */ function edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            val = val.source || val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */ function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n        let prot;\n        try {\n            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, \"\").toLowerCase();\n        } catch (e) {\n            return null;\n        }\n        if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n            return null;\n        }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n        href = resolveUrl(base, href);\n    }\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n/**\n * @param {string} base\n * @param {string} href\n */ function resolveUrl(base, href) {\n    if (!baseUrls[\" \" + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (justDomain.test(base)) {\n            baseUrls[\" \" + base] = base + \"/\";\n        } else {\n            baseUrls[\" \" + base] = rtrim(base, \"/\", true);\n        }\n    }\n    base = baseUrls[\" \" + base];\n    const relativeBase = base.indexOf(\":\") === -1;\n    if (href.substring(0, 2) === \"//\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(protocol, \"$1\") + href;\n    } else if (href.charAt(0) === \"/\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(domain, \"$1\") + href;\n    } else {\n        return base + href;\n    }\n}\nconst noopTest = {\n    exec: function noopTest() {}\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false, curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (cells.length > count) {\n        cells.splice(count);\n    } else {\n        while(cells.length < count)cells.push(\"\");\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    const l = str.length;\n    let level = 0, i = 0;\n    for(; i < l; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction checkDeprecations(opt, callback) {\n    if (!opt || opt.silent) {\n        return;\n    }\n    if (callback) {\n        console.warn(\"marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async\");\n    }\n    if (opt.sanitize || opt.sanitizer) {\n        console.warn(\"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options\");\n    }\n    if (opt.highlight || opt.langPrefix !== \"language-\") {\n        console.warn(\"marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.\");\n    }\n    if (opt.mangle) {\n        console.warn(\"marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.\");\n    }\n    if (opt.baseUrl) {\n        console.warn(\"marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.\");\n    }\n    if (opt.smartypants) {\n        console.warn(\"marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.\");\n    }\n    if (opt.xhtml) {\n        console.warn(\"marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.\");\n    }\n    if (opt.headerIds || opt.headerPrefix) {\n        console.warn(\"marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.\");\n    }\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class Tokenizer {\n    constructor(options){\n        this.options = options || defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ *>[ \\t]?/gm, \"\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            // Check if current bullet point can start a new List Item\n            while(src){\n                endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                nextLine = src.split(\"\\n\", 1)[0];\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimLeft();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            const l = list.items.length;\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(i = 0; i < l; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(i = 0; i < l; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: !this.options.sanitizer && (cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\"),\n                text: cap[0]\n            };\n            if (this.options.sanitize) {\n                const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n                token.type = \"paragraph\";\n                token.text = text;\n                token.tokens = this.lexer.inline(text);\n            }\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (cap) {\n            const item = {\n                type: \"table\",\n                header: splitCells(cap[1]).map((c)=>{\n                    return {\n                        text: c\n                    };\n                }),\n                align: cap[2].replace(/^ *|\\| *$/g, \"\").split(/ *\\| */),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                item.raw = cap[0];\n                let l = item.align.length;\n                let i, j, k, row;\n                for(i = 0; i < l; i++){\n                    if (/^ *-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"right\";\n                    } else if (/^ *:-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"center\";\n                    } else if (/^ *:-+ *$/.test(item.align[i])) {\n                        item.align[i] = \"left\";\n                    } else {\n                        item.align[i] = null;\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map((c)=>{\n                        return {\n                            text: c\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: this.options.sanitize ? \"text\" : \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            let link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            const lLength = match[0].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = rDelim.length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                const raw = src.slice(0, lLength + match.index + rLength + 1);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src, mangle) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src, mangle) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src, smartypants) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n                text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ const block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^((?:(?!^bull ).|\\n(?!\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.lheading = edit(block.lheading).replace(/bull/g, block.bullet) // lists can interrupt\n.getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = {\n    ...block\n};\n/**\n * GFM Block Grammar\n */ block.gfm = {\n    ...block.normal,\n    table: \"^ *([^\\\\n ].*\\\\|.*)\\\\n\" // Header\n     + \" {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n};\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = {\n    ...block.normal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ const inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/,\n        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a\n        rDelimAst: /^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])/,\n        rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^((?![*_])[\\spunctuation])/\n};\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\ninline._punctuation = \"\\\\p{P}$+<=>`^|~\";\ninline.punctuation = edit(inline.punctuation, \"u\").replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\ninline.anyPunctuation = /\\\\[punct]/g;\ninline._escapes = /\\\\([punct])/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim, \"u\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.anyPunctuation = edit(inline.anyPunctuation, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = edit(inline._escapes, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = {\n    ...inline\n};\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = {\n    ...inline.normal,\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ inline.gfm = {\n    ...inline.normal,\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = {\n    ...inline.gfm,\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * smartypants text replacement\n * @param {string} text\n */ function smartypants(text) {\n    return text// em-dashes\n    .replace(/---/g, \"—\")// en-dashes\n    .replace(/--/g, \"–\")// opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1‘\")// closing singles & apostrophes\n    .replace(/'/g, \"’\")// opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1“\")// closing doubles\n    .replace(/\"/g, \"”\")// ellipses\n    .replace(/\\.{3}/g, \"…\");\n}\n/**\n * mangle email addresses\n * @param {string} text\n */ function mangle(text) {\n    let out = \"\", i, ch;\n    const l = text.length;\n    for(i = 0; i < l; i++){\n        ch = text.charCodeAt(i);\n        if (Math.random() > 0.5) {\n            ch = \"x\" + ch.toString(16);\n        }\n        out += \"&#\" + ch + \";\";\n    }\n    return out;\n}\n/**\n * Block Lexer\n */ class Lexer {\n    constructor(options){\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || defaults;\n        this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n   * Expose Rules\n   */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n   * Static Lex Method\n   */ static lex(src, options) {\n        const lexer = new Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n   * Static Lex Inline Method\n   */ static lexInline(src, options) {\n        const lexer = new Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n   * Preprocessing\n   */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        let next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    }\n    /**\n   * Lexing\n   */ blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token, lastToken, cutSrc, lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach(function(getStartIndex) {\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n   * Lexing/Compiling\n   */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src, mangle)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach(function(getStartIndex) {\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class Renderer {\n    constructor(options){\n        this.options = options || defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/\\S*/)[0];\n        if (this.options.highlight) {\n            const out = this.options.highlight(code, lang);\n            if (out != null && out !== code) {\n                escaped = true;\n                code = out;\n            }\n        }\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"' + this.options.langPrefix + escape(lang) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    /**\n   * @param {string} quote\n   */ blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */ heading(text, level, raw, slugger) {\n        if (this.options.headerIds) {\n            const id = this.options.headerPrefix + slugger.slug(raw);\n            return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n        }\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return this.options.xhtml ? \"<hr/>\\n\" : \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\", startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    /**\n   * @param {string} text\n   */ listitem(text) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? \" /\" : \"\") + \"> \";\n    }\n    /**\n   * @param {string} text\n   */ paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    /**\n   * @param {string} header\n   * @param {string} body\n   */ table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    /**\n   * @param {string} content\n   */ tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n   * span level renderer\n   * @param {string} text\n   */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    /**\n   * @param {string} text\n   */ em(text) {\n        return `<em>${text}</em>`;\n    }\n    /**\n   * @param {string} text\n   */ codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return this.options.xhtml ? \"<br/>\" : \"<br>\";\n    }\n    /**\n   * @param {string} text\n   */ del(text) {\n        return `<del>${text}</del>`;\n    }\n    /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ link(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ image(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += this.options.xhtml ? \"/>\" : \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Slugger generates header id\n */ class Slugger {\n    constructor(){\n        this.seen = {};\n    }\n    /**\n   * @param {string} value\n   */ serialize(value) {\n        return value.toLowerCase().trim()// remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, \"\")// remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, \"\").replace(/\\s/g, \"-\");\n    }\n    /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */ getNextSafeSlug(originalSlug, isDryRun) {\n        let slug = originalSlug;\n        let occurenceAccumulator = 0;\n        if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n                occurenceAccumulator++;\n                slug = originalSlug + \"-\" + occurenceAccumulator;\n            }while (this.seen.hasOwnProperty(slug));\n        }\n        if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n        }\n        return slug;\n    }\n    /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */ slug(value, options = {}) {\n        const slug = this.serialize(value);\n        return this.getNextSafeSlug(slug, options.dryrun);\n    }\n}\n/**\n * Parsing & Compiling\n */ class Parser {\n    constructor(options){\n        this.options = options || defaults;\n        this.options.renderer = this.options.renderer || new Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new TextRenderer();\n        this.slugger = new Slugger();\n    }\n    /**\n   * Static Parse Method\n   */ static parse(tokens, options) {\n        const parser = new Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n   * Static Parse Inline Method\n   */ static parseInline(tokens, options) {\n        const parser = new Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n   * Parse Loop\n   */ parse(tokens, top = true) {\n        let out = \"\", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;\n        const l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token.text, token.lang, token.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        header = \"\";\n                        // header\n                        cell = \"\";\n                        l2 = token.header.length;\n                        for(j = 0; j < l2; j++){\n                            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                                header: true,\n                                align: token.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        body = \"\";\n                        l2 = token.rows.length;\n                        for(j = 0; j < l2; j++){\n                            row = token.rows[j];\n                            cell = \"\";\n                            l3 = row.length;\n                            for(k = 0; k < l3; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: token.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        body = this.parse(token.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        ordered = token.ordered;\n                        start = token.start;\n                        loose = token.loose;\n                        l2 = token.items.length;\n                        body = \"\";\n                        for(j = 0; j < l2; j++){\n                            item = token.items[j];\n                            checked = item.checked;\n                            task = item.task;\n                            itemBody = \"\";\n                            if (item.task) {\n                                checkbox = this.renderer.checkbox(checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox;\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        out += this.renderer.html(token.text, token.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(this.parseInline(token.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        body = token.tokens ? this.parseInline(token.tokens) : token.text;\n                        while(i + 1 < l && tokens[i + 1].type === \"text\"){\n                            token = tokens[++i];\n                            body += \"\\n\" + (token.tokens ? this.parseInline(token.tokens) : token.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n   * Parse Inline Tokens\n   */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\", i, token, ret;\n        const l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token.href, token.title, token.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass Hooks {\n    constructor(options){\n        this.options = options || defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\"\n        ]);\n    }\n    /**\n   * Process markdown before marked\n   */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n   * Process HTML after marked is finished\n   */ postprocess(html) {\n        return html;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(Lexer.lex, Parser.parse);\n        this.parseInline = this.#parseMarkdown(Lexer.lexInline, Parser.parseInline);\n        this.Parser = Parser;\n        this.parser = Parser.parse;\n        this.Renderer = Renderer;\n        this.TextRenderer = TextRenderer;\n        this.Lexer = Lexer;\n        this.lexer = Lexer.lex;\n        this.Tokenizer = Tokenizer;\n        this.Slugger = Slugger;\n        this.Hooks = Hooks;\n        this.use(...args);\n    }\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        for (const cell of token.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of token.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        values = values.concat(this.walkTokens(token.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        if (this.defaults.extensions && this.defaults.extensions.childTokens && this.defaults.extensions.childTokens[token.type]) {\n                            this.defaults.extensions.childTokens[token.type].forEach((childTokens)=>{\n                                values = values.concat(this.walkTokens(token[childTokens], callback));\n                            });\n                        } else if (token.tokens) {\n                            values = values.concat(this.walkTokens(token.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (ext.renderer) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (ext.tokenizer) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        if (extensions[ext.level]) {\n                            extensions[ext.level].unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    const prevRenderer = renderer[prop];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[prop] = (...args)=>{\n                        let ret = pack.renderer[prop].apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    const prevTokenizer = tokenizer[prop];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[prop] = (...args)=>{\n                        let ret = pack.tokenizer[prop].apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new Hooks();\n                for(const prop in pack.hooks){\n                    const prevHook = hooks[prop];\n                    if (Hooks.passThroughHooks.has(prop)) {\n                        hooks[prop] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = pack.hooks[prop].call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[prop] = (...args)=>{\n                            let ret = pack.hooks[prop].apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(pack.walkTokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, opt, callback)=>{\n            if (typeof opt === \"function\") {\n                callback = opt;\n                opt = null;\n            }\n            const origOpt = {\n                ...opt\n            };\n            opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            const throwError = this.#onError(opt.silent, opt.async, callback);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            checkDeprecations(opt, callback);\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (callback) {\n                const highlight = opt.highlight;\n                let tokens;\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    tokens = lexer(src, opt);\n                } catch (e) {\n                    return throwError(e);\n                }\n                const done = (err)=>{\n                    let out;\n                    if (!err) {\n                        try {\n                            if (opt.walkTokens) {\n                                this.walkTokens(tokens, opt.walkTokens);\n                            }\n                            out = parser(tokens, opt);\n                            if (opt.hooks) {\n                                out = opt.hooks.postprocess(out);\n                            }\n                        } catch (e) {\n                            err = e;\n                        }\n                    }\n                    opt.highlight = highlight;\n                    return err ? throwError(err) : callback(null, out);\n                };\n                if (!highlight || highlight.length < 3) {\n                    return done();\n                }\n                delete opt.highlight;\n                if (!tokens.length) return done();\n                let pending = 0;\n                this.walkTokens(tokens, (token)=>{\n                    if (token.type === \"code\") {\n                        pending++;\n                        setTimeout(()=>{\n                            highlight(token.text, token.lang, (err, code)=>{\n                                if (err) {\n                                    return done(err);\n                                }\n                                if (code != null && code !== token.text) {\n                                    token.text = code;\n                                    token.escaped = true;\n                                }\n                                pending--;\n                                if (pending === 0) {\n                                    done();\n                                }\n                            });\n                        }, 0);\n                    }\n                });\n                if (pending === 0) {\n                    done();\n                }\n                return;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                const tokens = lexer(src, opt);\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async, callback) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                if (callback) {\n                    callback(null, msg);\n                    return;\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            if (callback) {\n                callback(e);\n                return;\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked(defaults);\n/**\n * Marked\n */ function marked(src, opt, callback) {\n    return markedInstance.parse(src, opt, callback);\n}\n/**\n * Options\n */ marked.options = marked.setOptions = function(opt) {\n    markedInstance.setOptions(opt);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\nmarked.getDefaults = getDefaults;\nmarked.defaults = defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Parse Inline\n * @param {string} src\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.Hooks = Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = Parser.parse;\nconst lexer = Lexer.lex;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBRUQ7OztDQUdDLEdBRUQsU0FBU0E7SUFDUCxPQUFPO1FBQ0xDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsS0FBSztRQUNMQyxXQUFXO1FBQ1hDLGNBQWM7UUFDZEMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLFlBQVk7UUFDWkMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxXQUFXO1FBQ1hDLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLFlBQVk7UUFDWkMsT0FBTztJQUNUO0FBQ0Y7QUFFQSxJQUFJQyxXQUFXckI7QUFFZixTQUFTc0IsZUFBZUMsV0FBVztJQUNqQ0YsV0FBV0U7QUFDYjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxnQkFBZ0IsSUFBSUMsT0FBT0YsV0FBV0csTUFBTSxFQUFFO0FBQ3BELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx3QkFBd0IsSUFBSUgsT0FBT0UsbUJBQW1CRCxNQUFNLEVBQUU7QUFDcEUsTUFBTUcscUJBQXFCO0lBQ3pCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUIsQ0FBQ0MsS0FBT0Ysa0JBQWtCLENBQUNFLEdBQUc7QUFDM0QsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxNQUFNO0lBQzFCLElBQUlBLFFBQVE7UUFDVixJQUFJWCxXQUFXWSxJQUFJLENBQUNGLE9BQU87WUFDekIsT0FBT0EsS0FBS0csT0FBTyxDQUFDWixlQUFlTTtRQUNyQztJQUNGLE9BQU87UUFDTCxJQUFJSCxtQkFBbUJRLElBQUksQ0FBQ0YsT0FBTztZQUNqQyxPQUFPQSxLQUFLRyxPQUFPLENBQUNS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QUVBOztDQUVDLEdBRURBLE9BQU94VixVQUFVLEdBQUcsU0FBU2tHLE1BQU0sRUFBRWQsUUFBUTtJQUMzQyxPQUFPbVEsZUFBZXZWLFVBQVUsQ0FBQ2tHLFFBQVFkO0FBQzNDO0FBRUE7OztDQUdDLEdBQ0RvUSxPQUFPakQsV0FBVyxHQUFHZ0QsZUFBZWhELFdBQVc7QUFFL0M7O0NBRUMsR0FDRGlELE9BQU9yRCxNQUFNLEdBQUdBO0FBQ2hCcUQsT0FBT2xELE1BQU0sR0FBR0gsT0FBT0UsS0FBSztBQUM1Qm1ELE9BQU8vRSxRQUFRLEdBQUdBO0FBQ2xCK0UsT0FBT2hFLFlBQVksR0FBR0E7QUFDdEJnRSxPQUFPNUcsS0FBSyxHQUFHQTtBQUNmNEcsT0FBTzdQLEtBQUssR0FBR2lKLE1BQU1JLEdBQUc7QUFDeEJ3RyxPQUFPNU8sU0FBUyxHQUFHQTtBQUNuQjRPLE9BQU8vRCxPQUFPLEdBQUdBO0FBQ2pCK0QsT0FBT3pDLEtBQUssR0FBR0E7QUFDZnlDLE9BQU9uRCxLQUFLLEdBQUdtRDtBQUVmLE1BQU0xTyxVQUFVME8sT0FBTzFPLE9BQU87QUFDOUIsTUFBTXlNLGFBQWFpQyxPQUFPakMsVUFBVTtBQUNwQyxNQUFNRSxNQUFNK0IsT0FBTy9CLEdBQUc7QUFDdEIsTUFBTXpULGFBQWF3VixPQUFPeFYsVUFBVTtBQUNwQyxNQUFNdVMsY0FBY2lELE9BQU9qRCxXQUFXO0FBQ3RDLE1BQU1GLFFBQVFtRDtBQUNkLE1BQU1sRCxTQUFTSCxPQUFPRSxLQUFLO0FBQzNCLE1BQU0xTSxRQUFRaUosTUFBTUksR0FBRztBQUVxSyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanM/YzczOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCB2NS4xLjIgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMjMsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuLyoqXG4gKiBETyBOT1QgRURJVCBUSElTIEZJTEVcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaWxlcyBpbiAuL3NyYy9cbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYzogZmFsc2UsXG4gICAgYmFzZVVybDogbnVsbCxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgZ2ZtOiB0cnVlLFxuICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBob29rczogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICBtYW5nbGU6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICBzYW5pdGl6ZXI6IG51bGwsXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgdG9rZW5pemVyOiBudWxsLFxuICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgeGh0bWw6IGZhbHNlXG4gIH07XG59XG5cbmxldCBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG5cbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3Quc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISgjXFxkezEsN318I1tYeF1bYS1mQS1GMC05XXsxLDZ9fFxcdyspOykvO1xuY29uc3QgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0Tm9FbmNvZGUuc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuY29uc3QgZ2V0RXNjYXBlUmVwbGFjZW1lbnQgPSAoY2gpID0+IGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIGlmIChlbmNvZGUpIHtcbiAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBodG1sO1xufVxuXG5jb25zdCB1bmVzY2FwZVRlc3QgPSAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gIHJldHVybiBodG1sLnJlcGxhY2UodW5lc2NhcGVUZXN0LCAoXywgbikgPT4ge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuY29uc3QgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSByZWdleFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdFxuICovXG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSB0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnID8gcmVnZXggOiByZWdleC5zb3VyY2U7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgY29uc3Qgb2JqID0ge1xuICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG5jb25zdCBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBzYW5pdGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXJsKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gIGlmIChzYW5pdGl6ZSkge1xuICAgIGxldCBwcm90O1xuICAgIHRyeSB7XG4gICAgICBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICB9XG4gIHRyeSB7XG4gICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBocmVmO1xufVxuXG5jb25zdCBiYXNlVXJscyA9IHt9O1xuY29uc3QganVzdERvbWFpbiA9IC9eW146XSs6XFwvKlteL10qJC87XG5jb25zdCBwcm90b2NvbCA9IC9eKFteOl0rOilbXFxzXFxTXSokLztcbmNvbnN0IGRvbWFpbiA9IC9eKFteOl0rOlxcLypbXi9dKilbXFxzXFxTXSokLztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGhyZWZcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAvLyB3ZSBjYW4gaWdub3JlIGV2ZXJ5dGhpbmcgaW4gYmFzZSBhZnRlciB0aGUgbGFzdCBzbGFzaCBvZiBpdHMgcGF0aCBjb21wb25lbnQsXG4gICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgIGlmIChqdXN0RG9tYWluLnRlc3QoYmFzZSkpIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBydHJpbShiYXNlLCAnLycsIHRydWUpO1xuICAgIH1cbiAgfVxuICBiYXNlID0gYmFzZVVybHNbJyAnICsgYmFzZV07XG4gIGNvbnN0IHJlbGF0aXZlQmFzZSA9IGJhc2UuaW5kZXhPZignOicpID09PSAtMTtcblxuICBpZiAoaHJlZi5zdWJzdHJpbmcoMCwgMikgPT09ICcvLycpIHtcbiAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICByZXR1cm4gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShwcm90b2NvbCwgJyQxJykgKyBocmVmO1xuICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICByZXR1cm4gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShkb21haW4sICckMScpICsgaHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gIH1cbn1cblxuY29uc3Qgbm9vcFRlc3QgPSB7IGV4ZWM6IGZ1bmN0aW9uIG5vb3BUZXN0KCkge30gfTtcblxuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyID0gb2Zmc2V0O1xuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgIHJldHVybiAnfCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gIGxldCBpID0gMDtcblxuICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgaWYgKCFjZWxsc1swXS50cmltKCkpIHsgY2VsbHMuc2hpZnQoKTsgfVxuICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7IGNlbGxzLnBvcCgpOyB9XG5cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpIGNlbGxzLnB1c2goJycpO1xuICB9XG5cbiAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydCBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuICovXG5mdW5jdGlvbiBydHJpbShzdHIsIGMsIGludmVydCkge1xuICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgaWYgKGwgPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICBsZXQgc3VmZkxlbiA9IDA7XG5cbiAgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG4gIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgIGNvbnN0IGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICBzdWZmTGVuKys7XG4gICAgfSBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBsIC0gc3VmZkxlbik7XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgbGV0IGxldmVsID0gMCxcbiAgICBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGlvbnMob3B0LCBjYWxsYmFjaykge1xuICBpZiAoIW9wdCB8fCBvcHQuc2lsZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogY2FsbGJhY2sgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnL3VzaW5nX3BybyNhc3luYycpO1xuICB9XG5cbiAgaWYgKG9wdC5zYW5pdGl6ZSB8fCBvcHQuc2FuaXRpemVyKSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gIH1cblxuICBpZiAob3B0LmhpZ2hsaWdodCB8fCBvcHQubGFuZ1ByZWZpeCAhPT0gJ2xhbmd1YWdlLScpIHtcbiAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBoaWdobGlnaHQgYW5kIGxhbmdQcmVmaXggcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbnN0ZWFkIHVzZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tYXJrZWQtaGlnaGxpZ2h0LicpO1xuICB9XG5cbiAgaWYgKG9wdC5tYW5nbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBtYW5nbGUgcGFyYW1ldGVyIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCwgYnV0IGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBUbyBjbGVhciB0aGlzIHdhcm5pbmcsIGluc3RhbGwgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLW1hbmdsZSwgb3IgZGlzYWJsZSBieSBzZXR0aW5nIGB7bWFuZ2xlOiBmYWxzZX1gLicpO1xuICB9XG5cbiAgaWYgKG9wdC5iYXNlVXJsKSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogYmFzZVVybCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbnN0ZWFkIHVzZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tYXJrZWQtYmFzZS11cmwuJyk7XG4gIH1cblxuICBpZiAob3B0LnNtYXJ0eXBhbnRzKSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc21hcnR5cGFudHMgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gSW5zdGVhZCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLXNtYXJ0eXBhbnRzLicpO1xuICB9XG5cbiAgaWYgKG9wdC54aHRtbCkge1xuICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHhodG1sIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIEluc3RlYWQgdXNlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21hcmtlZC14aHRtbC4nKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVySWRzIHx8IG9wdC5oZWFkZXJQcmVmaXgpIHtcbiAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBoZWFkZXJJZHMgYW5kIGhlYWRlclByZWZpeCBwYXJhbWV0ZXJzIGVuYWJsZWQgYnkgZGVmYXVsdCwgYnV0IGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gVG8gY2xlYXIgdGhpcyB3YXJuaW5nLCBpbnN0YWxsICBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tYXJrZWQtZ2ZtLWhlYWRpbmctaWQsIG9yIGRpc2FibGUgYnkgc2V0dGluZyBge2hlYWRlcklkczogZmFsc2V9YC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICBjb25zdCBocmVmID0gbGluay5ocmVmO1xuICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgcmF3LFxuICAgICAgaHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdGV4dCxcbiAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgfTtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnaW1hZ2UnLFxuICAgIHJhdyxcbiAgICBocmVmLFxuICAgIHRpdGxlLFxuICAgIHRleHQ6IGVzY2FwZSh0ZXh0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICBjb25zdCBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICBpZiAobWF0Y2hJbmRlbnRUb0NvZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGNvbnN0IGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuXG4gIHJldHVybiB0ZXh0XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICBjb25zdCBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG4gICAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtpbmRlbnRJbk5vZGVdID0gbWF0Y2hJbmRlbnRJbk5vZGU7XG5cbiAgICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc2xpY2UoaW5kZW50VG9Db2RlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBUb2tlbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cztcbiAgfVxuXG4gIHNwYWNlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29kZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgIDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmZW5jZXMoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICByYXcsXG4gICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaGVhZGluZyhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcblxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBydHJpbSh0ZXh0LCAnIycpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0LFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGhyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ibG9ja3F1b3RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj5bIFxcdF0/L2dtLCAnJyk7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCk7XG4gICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBsaXN0KHNyYykge1xuICAgIGxldCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCByYXcsIGlzdGFzaywgaXNjaGVja2VkLCBpbmRlbnQsIGksIGJsYW5rTGluZSwgZW5kc1dpdGhCbGFua0xpbmUsXG4gICAgICAgIGxpbmUsIG5leHRMaW5lLCByYXdMaW5lLCBpdGVtQ29udGVudHMsIGVuZEVhcmx5O1xuXG4gICAgICBsZXQgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICBjb25zdCBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG5cbiAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBidWxsID0gaXNvcmRlcmVkID8gYFxcXFxkezEsOX1cXFxcJHtidWxsLnNsaWNlKC0xKX1gIDogYFxcXFwke2J1bGx9YDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6ICdbKistXSc7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBuZXh0IGxpc3QgaXRlbVxuICAgICAgY29uc3QgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICBpbmRlbnQgPSAyO1xuICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUudHJpbUxlZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKC9bXiBdLyk7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxhbmtMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFsaW5lICYmIC9eICokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKG5leHRMaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW5kRWFybHkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgY29uc3QgZmVuY2VzQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86XFxgXFxgXFxgfH5+filgKTtcbiAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZm9sbG93aW5nIGxpbmVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBMaXN0IEl0ZW1cbiAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICByYXdMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgIG5leHRMaW5lID0gcmF3TGluZTtcblxuICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL14gezEsNH0oPz0oIHs0fSkqW14gXSkvZywgJyAgJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgaWYgKGJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcGFyYWdyYXBoIGNvbnRpbnVhdGlvbiB1bmxlc3MgbGFzdCBsaW5lIHdhcyBhIGRpZmZlcmVudCBibG9jayBsZXZlbCBlbGVtZW50XG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSAmJiAhbmV4dExpbmUudHJpbSgpKSB7IC8vIENoZWNrIGlmIGN1cnJlbnQgbGluZSBpcyBibGFua1xuICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYXcgKz0gcmF3TGluZSArICdcXG4nO1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXdMaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgbGluZSA9IG5leHRMaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9cXG4gKlxcbiAqJC8udGVzdChyYXcpKSB7XG4gICAgICAgICAgICBlbmRzV2l0aEJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXN0YXNrWzBdICE9PSAnWyBdICc7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICByYXcsXG4gICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdyA9IHJhdy50cmltUmlnaHQoKTtcbiAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0ID0gaXRlbUNvbnRlbnRzLnRyaW1SaWdodCgpO1xuICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcblxuICAgICAgY29uc3QgbCA9IGxpc3QuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gL1xcbi4qXFxuLy50ZXN0KHQucmF3KSk7XG5cbiAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIGh0bWwoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHByZTogIXRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgdG9rZW4udHlwZSA9ICdwYXJhZ3JhcGgnO1xuICAgICAgICB0b2tlbi50ZXh0ID0gdGV4dDtcbiAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUodGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgZGVmKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiAnJztcbiAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBjYXBbM107XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgdGFnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdGFibGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50YWJsZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXSkubWFwKGMgPT4geyByZXR1cm4geyB0ZXh0OiBjIH07IH0pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIHJvd3M6IGNhcFszXSAmJiBjYXBbM10udHJpbSgpID8gY2FwWzNdLnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICB9O1xuXG4gICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICBpdGVtLnJhdyA9IGNhcFswXTtcblxuICAgICAgICBsZXQgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICBsZXQgaSwgaiwgaywgcm93O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaXRlbS5yb3dzW2ldID0gc3BsaXRDZWxscyhpdGVtLnJvd3NbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCkubWFwKGMgPT4geyByZXR1cm4geyB0ZXh0OiBjIH07IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgY2hpbGQgdG9rZW5zIGluc2lkZSBoZWFkZXJzIGFuZCBjZWxsc1xuXG4gICAgICAgIC8vIGhlYWRlciBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0uaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIGl0ZW0uaGVhZGVyW2pdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKGl0ZW0uaGVhZGVyW2pdLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VsbCBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcm93W2tdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKHJvd1trXS50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsaGVhZGluZyhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHBhcmFncmFwaChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgOiBjYXBbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdGV4dChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMF0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGVzY2FwZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdGFnKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICd0ZXh0J1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gKHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgICA6IGVzY2FwZShjYXBbMF0pKVxuICAgICAgICAgIDogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGxpbmsoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubGluay5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICBpZiAoISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kaW5nIGFuZ2xlIGJyYWNrZXQgY2Fubm90IGJlIGVzY2FwZWRcbiAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICBpZiAoKHRyaW1tZWRVcmwubGVuZ3RoIC0gcnRyaW1TbGFzaC5sZW5ndGgpICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgIGNvbnN0IGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBjYXBbMF0uaW5kZXhPZignIScpID09PSAwID8gNSA6IDQ7XG4gICAgICAgICAgY29uc3QgbGlua0xlbiA9IHN0YXJ0ICsgY2FwWzFdLmxlbmd0aCArIGxhc3RQYXJlbkluZGV4O1xuICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgIGNhcFswXSA9IGNhcFswXS5zdWJzdHJpbmcoMCwgbGlua0xlbikudHJpbSgpO1xuICAgICAgICAgIGNhcFszXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaHJlZiA9IGNhcFsyXTtcbiAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICBjb25zdCBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgfVxuXG4gICAgICBocmVmID0gaHJlZi50cmltKCk7XG4gICAgICBpZiAoL148Ly50ZXN0KGhyZWYpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgfSwgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICB9XG4gIH1cblxuICByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICBsZXQgY2FwO1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgbGV0IGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvW1xccHtMfVxccHtOfV0vdSkpIHJldHVybjtcblxuICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG5cbiAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgY29uc3QgbExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgckRlbGltLCByTGVuZ3RoLCBkZWxpbVRvdGFsID0gbExlbmd0aCwgbWlkRGVsaW1Ub3RhbCA9IDA7XG5cbiAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQ7XG4gICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcblxuICAgICAgLy8gQ2xpcCBtYXNrZWRTcmMgdG8gc2FtZSBzZWN0aW9uIG9mIHN0cmluZyBhcyBzcmMgKG1vdmUgdG8gbGV4ZXI/KVxuICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCArIGxMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcblxuICAgICAgICBpZiAoIXJEZWxpbSkgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cblxuICAgICAgICByTGVuZ3RoID0gckRlbGltLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgZGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgaWYgKGxMZW5ndGggJSAzICYmICEoKGxMZW5ndGggKyByTGVuZ3RoKSAlIDMpKSB7XG4gICAgICAgICAgICBtaWREZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuXG4gICAgICAgIGlmIChkZWxpbVRvdGFsID4gMCkgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuXG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcbiAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG5cbiAgICAgICAgY29uc3QgcmF3ID0gc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICByYXcsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29kZXNwYW4oc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBicihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZGVsKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhdXRvbGluayhzcmMsIG1hbmdsZSkge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzFdKSA6IGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB1cmwoc3JjLCBtYW5nbGUpIHtcbiAgICBsZXQgY2FwO1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgIGxldCBwcmV2Q2FwWmVybztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pWzBdO1xuICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBjYXBbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaW5saW5lVGV4dChzcmMsIHNtYXJ0eXBhbnRzKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAodGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pKSA6IGNhcFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICBsaXN0OiAvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLyxcbiAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcFRlc3QsXG4gIGxoZWFkaW5nOiAvXigoPzooPyFeYnVsbCApLnxcXG4oPyFcXG58YnVsbCApKSs/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAvLyByZWdleCB0ZW1wbGF0ZSwgcGxhY2Vob2xkZXJzIHdpbGwgYmUgcmVwbGFjZWQgYWNjb3JkaW5nIHRvIGRpZmZlcmVudCBwYXJhZ3JhcGhcbiAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICBfcGFyYWdyYXBoOiAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLl9sYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFwufFteXFxbXFxdXFxcXF0pKy87XG5ibG9jay5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuYmxvY2suZGVmID0gZWRpdChibG9jay5kZWYpXG4gIC5yZXBsYWNlKCdsYWJlbCcsIGJsb2NrLl9sYWJlbClcbiAgLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2suX3RpdGxlKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuYmxvY2subGlzdEl0ZW1TdGFydCA9IGVkaXQoL14oICopKGJ1bGwpICovKVxuICAucmVwbGFjZSgnYnVsbCcsIGJsb2NrLmJ1bGxldClcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmxpc3QgPSBlZGl0KGJsb2NrLmxpc3QpXG4gIC5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgLnJlcGxhY2UoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/Oig/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JCkpJylcbiAgLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgKyAnfGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWUnXG4gICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICArICd8dHJhY2t8dWwnO1xuYmxvY2suX2NvbW1lbnQgPSAvPCEtLSg/IS0/PilbXFxzXFxTXSo/KD86LS0+fCQpLztcbmJsb2NrLmh0bWwgPSBlZGl0KGJsb2NrLmh0bWwsICdpJylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpXG4gIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGhlYWRpbmcgPSBlZGl0KGJsb2NrLmxoZWFkaW5nKVxuICAucmVwbGFjZSgvYnVsbC9nLCBibG9jay5idWxsZXQpIC8vIGxpc3RzIGNhbiBpbnRlcnJ1cHRcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaClcbiAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5ibG9ja3F1b3RlID0gZWRpdChibG9jay5ibG9ja3F1b3RlKVxuICAucmVwbGFjZSgncGFyYWdyYXBoJywgYmxvY2sucGFyYWdyYXBoKVxuICAuZ2V0UmVnZXgoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IHsgLi4uYmxvY2sgfTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IHtcbiAgLi4uYmxvY2subm9ybWFsLFxuICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn07XG5cbmJsb2NrLmdmbS50YWJsZSA9IGVkaXQoYmxvY2suZ2ZtLnRhYmxlKVxuICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpXG4gIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKVxuICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaClcbiAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgLnJlcGxhY2UoJ3RhYmxlJywgYmxvY2suZ2ZtLnRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuXG5ibG9jay5wZWRhbnRpYyA9IHtcbiAgLi4uYmxvY2subm9ybWFsLFxuICBodG1sOiBlZGl0KFxuICAgICdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAgIC5yZXBsYWNlKC90YWcvZywgJyg/ISg/OidcbiAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKSdcbiAgICAgICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpXG4gICAgLmdldFJlZ2V4KCksXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICBmZW5jZXM6IG5vb3BUZXN0LCAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICBsaGVhZGluZzogL14oLis/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IGVkaXQoYmxvY2subm9ybWFsLl9wYXJhZ3JhcGgpXG4gICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpXG4gICAgLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAucmVwbGFjZSgnfGxpc3QnLCAnJylcbiAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAuZ2V0UmVnZXgoKVxufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICB1cmw6IG5vb3BUZXN0LFxuICB0YWc6ICdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JywgLy8gQ0RBVEEgc2VjdGlvblxuICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgZW1TdHJvbmc6IHtcbiAgICBsRGVsaW06IC9eKD86XFwqKyg/OigoPyFcXCopW3B1bmN0XSl8W15cXHMqXSkpfF5fKyg/OigoPyFfKVtwdW5jdF0pfChbXlxcc19dKSkvLFxuICAgIC8vICAgICAgICAgKDEpIGFuZCAoMikgY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXIuICgzKSBhbmQgKDQpIGNhbiBvbmx5IGJlIExlZnQuICAoNSkgYW5kICg2KSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQuXG4gICAgLy8gICAgICAgICB8IFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmcgICAgICB8IENvbnN1bWUgdG8gZGVsaW0gfCAoMSkgIyoqKiAgICAgICAgICAgICAgfCAoMikgYSoqKiMsIGEqKiogICAgICAgICAgICAgICAgICAgIHwgKDMpICMqKiphLCAqKiphICAgICAgICAgICAgICAgICAgfCAoNCkgKioqIyAgICAgICAgICAgICAgICAgfCAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICAgICAgICAgfCAoNikgYSoqKmFcbiAgICByRGVsaW1Bc3Q6IC9eW15fKl0qP19fW15fKl0qP1xcKlteXypdKj8oPz1fXyl8W14qXSsoPz1bXipdKXwoPyFcXCopW3B1bmN0XShcXCorKSg/PVtcXHNdfCQpfFtecHVuY3RcXHNdKFxcKispKD8hXFwqKSg/PVtwdW5jdFxcc118JCl8KD8hXFwqKVtwdW5jdFxcc10oXFwqKykoPz1bXnB1bmN0XFxzXSl8W1xcc10oXFwqKykoPyFcXCopKD89W3B1bmN0XSl8KD8hXFwqKVtwdW5jdF0oXFwqKykoPyFcXCopKD89W3B1bmN0XSl8W15wdW5jdFxcc10oXFwqKykoPz1bXnB1bmN0XFxzXSkvLFxuICAgIHJEZWxpbVVuZDogL15bXl8qXSo/XFwqXFwqW15fKl0qP19bXl8qXSo/KD89XFwqXFwqKXxbXl9dKyg/PVteX10pfCg/IV8pW3B1bmN0XShfKykoPz1bXFxzXXwkKXxbXnB1bmN0XFxzXShfKykoPyFfKSg/PVtwdW5jdFxcc118JCl8KD8hXylbcHVuY3RcXHNdKF8rKSg/PVtecHVuY3RcXHNdKXxbXFxzXShfKykoPyFfKSg/PVtwdW5jdF0pfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICB9LFxuICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3BUZXN0LFxuICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICBwdW5jdHVhdGlvbjogL14oKD8hWypfXSlbXFxzcHVuY3R1YXRpb25dKS9cbn07XG5cbi8vIGxpc3Qgb2YgdW5pY29kZSBwdW5jdHVhdGlvbiBtYXJrcywgcGx1cyBhbnkgbWlzc2luZyBjaGFyYWN0ZXJzIGZyb20gQ29tbW9uTWFyayBzcGVjXG5pbmxpbmUuX3B1bmN0dWF0aW9uID0gJ1xcXFxwe1B9JCs8PT5gXnx+JztcbmlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQoaW5saW5lLnB1bmN0dWF0aW9uLCAndScpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5cbi8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5pbmxpbmUuYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKFteXFwoXFwpXSo/XFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuaW5saW5lLmFueVB1bmN0dWF0aW9uID0gL1xcXFxbcHVuY3RdL2c7XG5pbmxpbmUuX2VzY2FwZXMgPSAvXFxcXChbcHVuY3RdKS9nO1xuXG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLmxEZWxpbSwgJ3UnKVxuICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QsICdndScpXG4gIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCwgJ2d1JylcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuYW55UHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5hbnlQdW5jdHVhdGlvbiwgJ2d1JylcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2VzY2FwZXMgPSBlZGl0KGlubGluZS5fZXNjYXBlcywgJ2d1JylcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbmlubGluZS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbmlubGluZS5hdXRvbGluayA9IGVkaXQoaW5saW5lLmF1dG9saW5rKVxuICAucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcblxuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpXG4gIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fbGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbmlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcblxuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbClcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5ub2xpbmsgPSBlZGl0KGlubGluZS5ub2xpbmspXG4gIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJylcbiAgLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspXG4gIC5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSB7IC4uLmlubGluZSB9O1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0ge1xuICAuLi5pbmxpbmUubm9ybWFsLFxuICBzdHJvbmc6IHtcbiAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgIG1pZGRsZTogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gICAgZW5kQXN0OiAvXFwqXFwqKD8hXFwqKS9nLFxuICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICB9LFxuICBlbToge1xuICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICBtaWRkbGU6IC9eKClcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKXxeXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXykvLFxuICAgIGVuZEFzdDogL1xcKig/IVxcKikvZyxcbiAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICB9LFxuICBsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KCksXG4gIHJlZmxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXHMqXFxbKFteXFxdXSopXFxdLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5nZXRSZWdleCgpXG59O1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSB7XG4gIC4uLmlubGluZS5ub3JtYWwsXG4gIGVzY2FwZTogZWRpdChpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgX2V4dGVuZGVkX2VtYWlsOiAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvLFxuICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gIGRlbDogL14ofn4/KSg/PVteXFxzfl0pKFtcXHNcXFNdKj9bXlxcc35dKVxcMSg/PVtefl18JCkvLFxuICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpL1xufTtcblxuaW5saW5lLmdmbS51cmwgPSBlZGl0KGlubGluZS5nZm0udXJsLCAnaScpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5nZm0uX2V4dGVuZGVkX2VtYWlsKVxuICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0ge1xuICAuLi5pbmxpbmUuZ2ZtLFxuICBicjogZWRpdChpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gIHRleHQ6IGVkaXQoaW5saW5lLmdmbS50ZXh0KVxuICAgIC5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgLmdldFJlZ2V4KClcbn07XG5cbi8qKlxuICogc21hcnR5cGFudHMgdGV4dCByZXBsYWNlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqL1xuZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufVxuXG4vKipcbiAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKi9cbmZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gIGxldCBvdXQgPSAnJyxcbiAgICBpLFxuICAgIGNoO1xuXG4gIGNvbnN0IGwgPSB0ZXh0Lmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuY2xhc3MgTGV4ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnRva2Vucy5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cztcbiAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgIGluUmF3QmxvY2s6IGZhbHNlLFxuICAgICAgdG9wOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICBydWxlcy5ibG9jayA9IGJsb2NrLnBlZGFudGljO1xuICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLnBlZGFudGljO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuYnJlYWtzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgUnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrLFxuICAgICAgaW5saW5lXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIGxleChzcmMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAqL1xuICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcm9jZXNzaW5nXG4gICAqL1xuICBsZXgoc3JjKSB7XG4gICAgc3JjID0gc3JjXG4gICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG5cbiAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMpO1xuXG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKG5leHQgPSB0aGlzLmlubGluZVF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgIHRoaXMuaW5saW5lVG9rZW5zKG5leHQuc3JjLCBuZXh0LnRva2Vucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIExleGluZ1xuICAgKi9cbiAgYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eKCAqKShcXHQrKS9nbSwgKF8sIGxlYWRpbmcsIHRhYnMpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCB0b2tlbiwgbGFzdFRva2VuLCBjdXRTcmMsIGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuXG4gICAgd2hpbGUgKHNyYykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zXG4gICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrXG4gICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG5ld2xpbmVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgc2luZ2xlIFxcbiBhcyBhIHNwYWNlciwgaXQncyB0ZXJtaW5hdGluZyB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgIC8vIHNvIG1vdmUgaXQgdGhlcmUgc28gdGhhdCB3ZSBkb24ndCBnZXQgdW5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ucmF3ICs9ICdcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29kZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmVuY2VzXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5mZW5jZXMoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoZWFkaW5nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHJcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYmxvY2txdW90ZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpc3RcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBodG1sXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVmXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10gPSB7XG4gICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFibGUgKGdmbSlcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGhlYWRpbmdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goZnVuY3Rpb24oZ2V0U3RhcnRJbmRleCkge1xuICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkgeyBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFBhcmFncmFwaENsaXBwZWQgJiYgbGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGV4dFxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS50b3AgPSB0cnVlO1xuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBpbmxpbmUoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogTGV4aW5nL0NvbXBpbGluZ1xuICAgKi9cbiAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuXG4gICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcblxuICAgIC8vIE1hc2sgb3V0IHJlZmxpbmtzXG4gICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgIH1cblxuICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24ubGFzdEluZGV4KTtcbiAgICB9XG5cbiAgICB3aGlsZSAoc3JjKSB7XG4gICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG5cbiAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVzY2FwZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFnXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWcoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2RlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGJyXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5icihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXV0b2xpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cmwgKGdmbSlcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYywgbWFuZ2xlKSkpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGV4dFxuICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goZnVuY3Rpb24oZ2V0U3RhcnRJbmRleCkge1xuICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkgeyBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMsIHNtYXJ0eXBhbnRzKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7IC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuY2xhc3MgUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cztcbiAgfVxuXG4gIGNvZGUoY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgIGNvbnN0IGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL1xcUyovKVswXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgY29uc3Qgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIGNvZGUgPSBvdXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArICdcXG4nO1xuXG4gICAgaWYgKCFsYW5nKSB7XG4gICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICAgKyBlc2NhcGUobGFuZylcbiAgICAgICsgJ1wiPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1b3RlXG4gICAqL1xuICBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgcmV0dXJuIGA8YmxvY2txdW90ZT5cXG4ke3F1b3RlfTwvYmxvY2txdW90ZT5cXG5gO1xuICB9XG5cbiAgaHRtbChodG1sLCBibG9jaykge1xuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3XG4gICAqIEBwYXJhbSB7YW55fSBzbHVnZ2VyXG4gICAqL1xuICBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdyk7XG4gICAgICByZXR1cm4gYDxoJHtsZXZlbH0gaWQ9XCIke2lkfVwiPiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBJRHNcbiAgICByZXR1cm4gYDxoJHtsZXZlbH0+JHt0ZXh0fTwvaCR7bGV2ZWx9PlxcbmA7XG4gIH1cblxuICBocigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgfVxuXG4gIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgbGlzdGl0ZW0odGV4dCkge1xuICAgIHJldHVybiBgPGxpPiR7dGV4dH08L2xpPlxcbmA7XG4gIH1cblxuICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICAgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKVxuICAgICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIidcbiAgICAgICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJylcbiAgICAgICsgJz4gJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICByZXR1cm4gYDxwPiR7dGV4dH08L3A+XFxuYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAqL1xuICB0YWJsZShoZWFkZXIsIGJvZHkpIHtcbiAgICBpZiAoYm9keSkgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcblxuICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICArIGhlYWRlclxuICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICArIGJvZHlcbiAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgdGFibGVyb3coY29udGVudCkge1xuICAgIHJldHVybiBgPHRyPlxcbiR7Y29udGVudH08L3RyPlxcbmA7XG4gIH1cblxuICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICBjb25zdCB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgY29uc3QgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICAgID8gYDwke3R5cGV9IGFsaWduPVwiJHtmbGFncy5hbGlnbn1cIj5gXG4gICAgICA6IGA8JHt0eXBlfT5gO1xuICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICB9XG5cbiAgLyoqXG4gICAqIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIHN0cm9uZyh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqL1xuICBlbSh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8ZW0+JHt0ZXh0fTwvZW0+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiBgPGNvZGU+JHt0ZXh0fTwvY29kZT5gO1xuICB9XG5cbiAgYnIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGRlbCh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8ZGVsPiR7dGV4dH08L2RlbD5gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICB9XG4gICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuICAgIGlmIChocmVmID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7dGl0bGV9XCJgO1xuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5jbGFzcyBUZXh0UmVuZGVyZXIge1xuICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgc3Ryb25nKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGVtKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGNvZGVzcGFuKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGRlbCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBodG1sKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHRleHQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICBicigpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAqL1xuY2xhc3MgU2x1Z2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VlbiA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnRyaW0oKVxuICAgICAgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJylcbiAgICAgIC8vIHJlbW92ZSB1bndhbnRlZCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKVxuICAgICAgLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbmFsU2x1Z1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJ5UnVuXG4gICAqL1xuICBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgIGxldCBzbHVnID0gb3JpZ2luYWxTbHVnO1xuICAgIGxldCBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG4gICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcbiAgICAgIGRvIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzbHVnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZHJ5cnVuXSBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dFxuICAgKiB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAqL1xuICBzbHVnKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIoKTtcbiAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIExvb3BcbiAgICovXG4gIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgIGxldCBvdXQgPSAnJyxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIGwyLFxuICAgICAgbDMsXG4gICAgICByb3csXG4gICAgICBjZWxsLFxuICAgICAgaGVhZGVyLFxuICAgICAgYm9keSxcbiAgICAgIHRva2VuLFxuICAgICAgb3JkZXJlZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgbG9vc2UsXG4gICAgICBpdGVtQm9keSxcbiAgICAgIGl0ZW0sXG4gICAgICBjaGVja2VkLFxuICAgICAgdGFzayxcbiAgICAgIGNoZWNrYm94LFxuICAgICAgcmV0O1xuXG4gICAgY29uc3QgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpLFxuICAgICAgICAgICAgdG9rZW4uZGVwdGgsXG4gICAgICAgICAgICB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSxcbiAgICAgICAgICAgIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsXG4gICAgICAgICAgICB0b2tlbi5sYW5nLFxuICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgaGVhZGVyID0gJyc7XG5cbiAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcnNlSW5saW5lKHRva2VuLmhlYWRlcltqXS50b2tlbnMpLFxuICAgICAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgIGwyID0gdG9rZW4ucm93cy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHRva2VuLnJvd3Nbal07XG5cbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSxcbiAgICAgICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0b2tlbi5hbGlnbltrXSB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgIHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcbiAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuLnRleHQsIHRva2VuLmJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgKi9cbiAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgdG9rZW4sXG4gICAgICByZXQ7XG5cbiAgICBjb25zdCBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCB0b2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5rJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRva2VuLnRleHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5jbGFzcyBIb29rcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICB9XG5cbiAgc3RhdGljIHBhc3NUaHJvdWdoSG9va3MgPSBuZXcgU2V0KFtcbiAgICAncHJlcHJvY2VzcycsXG4gICAgJ3Bvc3Rwcm9jZXNzJ1xuICBdKTtcblxuICAvKipcbiAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAqL1xuICBwcmVwcm9jZXNzKG1hcmtkb3duKSB7XG4gICAgcmV0dXJuIG1hcmtkb3duO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICovXG4gIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbDtcbiAgfVxufVxuXG5jbGFzcyBNYXJrZWQge1xuICBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG4gIG9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnM7XG5cbiAgcGFyc2UgPSB0aGlzLiNwYXJzZU1hcmtkb3duKExleGVyLmxleCwgUGFyc2VyLnBhcnNlKTtcbiAgcGFyc2VJbmxpbmUgPSB0aGlzLiNwYXJzZU1hcmtkb3duKExleGVyLmxleElubGluZSwgUGFyc2VyLnBhcnNlSW5saW5lKTtcblxuICBQYXJzZXIgPSBQYXJzZXI7XG4gIHBhcnNlciA9IFBhcnNlci5wYXJzZTtcbiAgUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xuICBMZXhlciA9IExleGVyO1xuICBsZXhlciA9IExleGVyLmxleDtcbiAgVG9rZW5pemVyID0gVG9rZW5pemVyO1xuICBTbHVnZ2VyID0gU2x1Z2dlcjtcbiAgSG9va3MgPSBIb29rcztcblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy51c2UoLi4uYXJncyk7XG4gIH1cblxuICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0b2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0b2tlbi5yb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5leHRlbnNpb25zICYmIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2VucyAmJiB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0pIHsgLy8gV2FsayBhbnkgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdLmZvckVhY2goKGNoaWxkVG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VuW2NoaWxkVG9rZW5zXSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2Vucyh0b2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB1c2UoLi4uYXJncykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcblxuICAgIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnBhY2sgfTtcblxuICAgICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgICAgb3B0cy5hc3luYyA9IHRoaXMuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcblxuICAgICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHQucmVuZGVyZXIpIHsgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0LnRva2VuaXplcikgeyAvLyBUb2tlbml6ZXIgRXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbZXh0LmxldmVsXSkge1xuICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0udW5zaGlmdChleHQudG9rZW5pemVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHsgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcHJvcF07XG4gICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgIHJlbmRlcmVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCByZXQgPSBwYWNrLnJlbmRlcmVyW3Byb3BdLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgIGNvbnN0IHRva2VuaXplciA9IHRoaXMuZGVmYXVsdHMudG9rZW5pemVyIHx8IG5ldyBUb2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgIGNvbnN0IHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG4gICAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgbGV0IHJldCA9IHBhY2sudG9rZW5pemVyW3Byb3BdLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vID09LS0gUGFyc2UgSG9va3MgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICBpZiAocGFjay5ob29rcykge1xuICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuZGVmYXVsdHMuaG9va3MgfHwgbmV3IEhvb2tzKCk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgY29uc3QgcHJldkhvb2sgPSBob29rc1twcm9wXTtcbiAgICAgICAgICBpZiAoSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgIGhvb2tzW3Byb3BdID0gKGFyZykgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFjay5ob29rc1twcm9wXS5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHJldCA9IHBhY2suaG9va3NbcHJvcF0uY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rc1twcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZXQgPSBwYWNrLmhvb2tzW3Byb3BdLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBwcmV2SG9vay5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdHMuaG9va3MgPSBob29rcztcbiAgICAgIH1cblxuICAgICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgaWYgKHBhY2sud2Fsa1Rva2Vucykge1xuICAgICAgICBjb25zdCB3YWxrVG9rZW5zID0gdGhpcy5kZWZhdWx0cy53YWxrVG9rZW5zO1xuICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrLndhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0KSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0IH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAjcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gICAgcmV0dXJuIChzcmMsIG9wdCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHQgfTtcbiAgICAgIG9wdCA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3JpZ09wdCB9O1xuICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMuI29uRXJyb3Iob3B0LnNpbGVudCwgb3B0LmFzeW5jLCBjYWxsYmFjayk7XG5cbiAgICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICd1bmRlZmluZWQnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrRGVwcmVjYXRpb25zKG9wdCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgICAgbGV0IHRva2VucztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZG9uZSA9IChlcnIpID0+IHtcbiAgICAgICAgICBsZXQgb3V0O1xuXG4gICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKG91dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgICAgPyB0aHJvd0Vycm9yKGVycilcbiAgICAgICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHJldHVybiBkb25lKCk7XG5cbiAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xuICAgICAgICB0aGlzLndhbGtUb2tlbnModG9rZW5zLCAodG9rZW4pID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIChlcnIsIGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsICYmIGNvZGUgIT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQuYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgIC50aGVuKHNyYyA9PiBsZXhlcihzcmMsIG9wdCkpXG4gICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgLnRoZW4odG9rZW5zID0+IHBhcnNlcih0b2tlbnMsIG9wdCkpXG4gICAgICAgICAgLnRoZW4oaHRtbCA9PiBvcHQuaG9va3MgPyBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbCkgOiBodG1sKVxuICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgICB0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gICNvbkVycm9yKHNpbGVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgICArICc8L3ByZT4nO1xuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgIH1cblxuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IG1hcmtlZEluc3RhbmNlID0gbmV3IE1hcmtlZChkZWZhdWx0cyk7XG5cbi8qKlxuICogTWFya2VkXG4gKi9cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1hcmtlZEluc3RhbmNlLnNldE9wdGlvbnMob3B0KTtcbiAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcblxubWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIG1hcmtlZEluc3RhbmNlLnVzZSguLi5hcmdzKTtcbiAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xuXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uKHRva2VucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBhcnNlIElubGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1xuICovXG5tYXJrZWQucGFyc2VJbmxpbmUgPSBtYXJrZWRJbnN0YW5jZS5wYXJzZUlubGluZTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBUZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcbm1hcmtlZC5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tYXJrZWQuU2x1Z2dlciA9IFNsdWdnZXI7XG5tYXJrZWQuSG9va3MgPSBIb29rcztcbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5jb25zdCBsZXhlciA9IExleGVyLmxleDtcblxuZXhwb3J0IHsgSG9va3MsIExleGVyLCBNYXJrZWQsIFBhcnNlciwgUmVuZGVyZXIsIFNsdWdnZXIsIFRleHRSZW5kZXJlciwgVG9rZW5pemVyLCBkZWZhdWx0cywgZ2V0RGVmYXVsdHMsIGxleGVyLCBtYXJrZWQsIG9wdGlvbnMsIHBhcnNlLCBwYXJzZUlubGluZSwgcGFyc2VyLCBzZXRPcHRpb25zLCB1c2UsIHdhbGtUb2tlbnMgfTtcbiJdLCJuYW1lcyI6WyJnZXREZWZhdWx0cyIsImFzeW5jIiwiYmFzZVVybCIsImJyZWFrcyIsImV4dGVuc2lvbnMiLCJnZm0iLCJoZWFkZXJJZHMiLCJoZWFkZXJQcmVmaXgiLCJoaWdobGlnaHQiLCJob29rcyIsImxhbmdQcmVmaXgiLCJtYW5nbGUiLCJwZWRhbnRpYyIsInJlbmRlcmVyIiwic2FuaXRpemUiLCJzYW5pdGl6ZXIiLCJzaWxlbnQiLCJzbWFydHlwYW50cyIsInRva2VuaXplciIsIndhbGtUb2tlbnMiLCJ4aHRtbCIsImRlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwic291cmNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSIsImh0bWwiLCJlbmNvZGUiLCJ0ZXN0IiwicmVwbGFjZSIsInVuZXNjYXBlVGVzdCIsInVuZXNjYXBlIiwiXyIsIm4iLCJ0b0xvd2VyQ2FzZSIsImNoYXJBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiY2FyZXQiLCJlZGl0IiwicmVnZXgiLCJvcHQiLCJvYmoiLCJuYW1lIiwidmFsIiwiZ2V0UmVnZXgiLCJub25Xb3JkQW5kQ29sb25UZXN0Iiwib3JpZ2luSW5kZXBlbmRlbnRVcmwiLCJjbGVhblVybCIsImJhc2UiLCJocmVmIiwicHJvdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImUiLCJpbmRleE9mIiwicmVzb2x2ZVVybCIsImVuY29kZVVSSSIsImJhc2VVcmxzIiwianVzdERvbWFpbiIsInByb3RvY29sIiwiZG9tYWluIiwicnRyaW0iLCJyZWxhdGl2ZUJhc2UiLCJub29wVGVzdCIsImV4ZWMiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsInBvcCIsInNwbGljZSIsInB1c2giLCJjIiwiaW52ZXJ0IiwibCIsInN1ZmZMZW4iLCJjdXJyQ2hhciIsInNsaWNlIiwiZmluZENsb3NpbmdCcmFja2V0IiwiYiIsImxldmVsIiwiY2hlY2tEZXByZWNhdGlvbnMiLCJjYWxsYmFjayIsImNvbnNvbGUiLCJ3YXJuIiwib3V0cHV0TGluayIsImNhcCIsImxpbmsiLCJyYXciLCJsZXhlciIsInRpdGxlIiwidGV4dCIsInN0YXRlIiwiaW5MaW5rIiwidG9rZW4iLCJ0eXBlIiwidG9rZW5zIiwiaW5saW5lVG9rZW5zIiwiaW5kZW50Q29kZUNvbXBlbnNhdGlvbiIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIlRva2VuaXplciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInNwYWNlIiwic3JjIiwicnVsZXMiLCJibG9jayIsIm5ld2xpbmUiLCJjb2RlIiwiY29kZUJsb2NrU3R5bGUiLCJmZW5jZXMiLCJsYW5nIiwiaW5saW5lIiwiX2VzY2FwZXMiLCJoZWFkaW5nIiwidHJpbW1lZCIsImRlcHRoIiwiaHIiLCJibG9ja3F1b3RlIiwidG9wIiwiYmxvY2tUb2tlbnMiLCJsaXN0IiwiaXN0YXNrIiwiaXNjaGVja2VkIiwiaW5kZW50IiwiYmxhbmtMaW5lIiwiZW5kc1dpdGhCbGFua0xpbmUiLCJsaW5lIiwibmV4dExpbmUiLCJyYXdMaW5lIiwiaXRlbUNvbnRlbnRzIiwiZW5kRWFybHkiLCJidWxsIiwiaXNvcmRlcmVkIiwib3JkZXJlZCIsInN0YXJ0IiwibG9vc2UiLCJpdGVtcyIsIml0ZW1SZWdleCIsInQiLCJyZXBlYXQiLCJ0cmltTGVmdCIsInNlYXJjaCIsIm5leHRCdWxsZXRSZWdleCIsIk1hdGgiLCJtaW4iLCJoclJlZ2V4IiwiZmVuY2VzQmVnaW5SZWdleCIsImhlYWRpbmdCZWdpblJlZ2V4IiwidGFzayIsImNoZWNrZWQiLCJ0cmltUmlnaHQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsImRlZiIsInRhZyIsInRhYmxlIiwiaXRlbSIsImhlYWRlciIsImFsaWduIiwicm93cyIsImoiLCJrIiwibGhlYWRpbmciLCJwYXJhZ3JhcGgiLCJpblJhd0Jsb2NrIiwidHJpbW1lZFVybCIsInJ0cmltU2xhc2giLCJsYXN0UGFyZW5JbmRleCIsImxpbmtMZW4iLCJyZWZsaW5rIiwibGlua3MiLCJub2xpbmsiLCJlbVN0cm9uZyIsIm1hc2tlZFNyYyIsInByZXZDaGFyIiwibERlbGltIiwibmV4dENoYXIiLCJwdW5jdHVhdGlvbiIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJyRGVsaW1Bc3QiLCJyRGVsaW1VbmQiLCJsYXN0SW5kZXgiLCJpbmRleCIsImNvZGVzcGFuIiwiaGFzTm9uU3BhY2VDaGFycyIsImhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzIiwiYnIiLCJkZWwiLCJhdXRvbGluayIsInVybCIsInByZXZDYXBaZXJvIiwiX2JhY2twZWRhbCIsImlubGluZVRleHQiLCJfcGFyYWdyYXBoIiwiX2xhYmVsIiwiX3RpdGxlIiwiYnVsbGV0IiwibGlzdEl0ZW1TdGFydCIsIl90YWciLCJfY29tbWVudCIsIm5vcm1hbCIsInJlZmxpbmtTZWFyY2giLCJfcHVuY3R1YXRpb24iLCJibG9ja1NraXAiLCJhbnlQdW5jdHVhdGlvbiIsIl9zY2hlbWUiLCJfZW1haWwiLCJfYXR0cmlidXRlIiwiX2hyZWYiLCJzdHJvbmciLCJtaWRkbGUiLCJlbmRBc3QiLCJlbmRVbmQiLCJlbSIsIl9leHRlbmRlZF9lbWFpbCIsIm91dCIsImNoYXJDb2RlQXQiLCJyYW5kb20iLCJ0b1N0cmluZyIsIkxleGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJuZXh0IiwibGVhZGluZyIsInRhYnMiLCJsYXN0VG9rZW4iLCJjdXRTcmMiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsImNhbGwiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiZXJyb3IiLCJFcnJvciIsImtlZXBQcmV2Q2hhciIsImtleXMiLCJpbmNsdWRlcyIsImxhc3RJbmRleE9mIiwic3RhcnRJbmxpbmUiLCJSZW5kZXJlciIsImluZm9zdHJpbmciLCJxdW90ZSIsInNsdWdnZXIiLCJpZCIsInNsdWciLCJib2R5Iiwic3RhcnRhdHQiLCJsaXN0aXRlbSIsImNoZWNrYm94IiwidGFibGVyb3ciLCJjb250ZW50IiwidGFibGVjZWxsIiwiZmxhZ3MiLCJpbWFnZSIsIlRleHRSZW5kZXJlciIsIlNsdWdnZXIiLCJzZWVuIiwic2VyaWFsaXplIiwidmFsdWUiLCJnZXROZXh0U2FmZVNsdWciLCJvcmlnaW5hbFNsdWciLCJpc0RyeVJ1biIsIm9jY3VyZW5jZUFjY3VtdWxhdG9yIiwiaGFzT3duUHJvcGVydHkiLCJkcnlydW4iLCJQYXJzZXIiLCJ0ZXh0UmVuZGVyZXIiLCJwYXJzZSIsInBhcnNlciIsInBhcnNlSW5saW5lIiwibDIiLCJsMyIsImNlbGwiLCJpdGVtQm9keSIsInJldCIsInJlbmRlcmVycyIsInVuc2hpZnQiLCJIb29rcyIsInBhc3NUaHJvdWdoSG9va3MiLCJTZXQiLCJwcmVwcm9jZXNzIiwibWFya2Rvd24iLCJwb3N0cHJvY2VzcyIsIk1hcmtlZCIsImFyZ3MiLCJzZXRPcHRpb25zIiwicGFyc2VNYXJrZG93biIsInVzZSIsInZhbHVlcyIsImNvbmNhdCIsImNoaWxkVG9rZW5zIiwicGFjayIsIm9wdHMiLCJleHQiLCJwcmV2UmVuZGVyZXIiLCJhcHBseSIsInByb3AiLCJwcmV2VG9rZW5pemVyIiwicHJldkhvb2siLCJoYXMiLCJhcmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJvcmlnT3B0IiwidGhyb3dFcnJvciIsIm9uRXJyb3IiLCJwcm90b3R5cGUiLCJkb25lIiwiZXJyIiwicGVuZGluZyIsInNldFRpbWVvdXQiLCJhbGwiLCJjYXRjaCIsIm1lc3NhZ2UiLCJtc2ciLCJyZWplY3QiLCJtYXJrZWRJbnN0YW5jZSIsIm1hcmtlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;